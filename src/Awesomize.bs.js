// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Awesomize_util = require("./Awesomize_util.bs.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function definitionToJs(param) {
  return {
          read: param.read,
          sanitize: param.sanitize,
          validate: param.validate,
          normalize: param.normalize
        };
}

function definitionFromJs(param) {
  return {
          read: param.read,
          sanitize: param.sanitize,
          validate: param.validate,
          normalize: param.normalize
        };
}

function make(generator, definitionMap) {
  var step = Belt_MapString.valuesToArray(Belt_MapString.mapWithKey(definitionMap, generator));
  return function (input) {
    return Promise.all(Belt_Array.map(step, (function (fn) {
                        return Curry._1(fn, input);
                      }))).then(function (res) {
                return Promise.resolve(Belt_MapString.fromArray(res));
              });
  };
}

function actionOrDefault(parser, key, definition) {
  var fn = Curry._1(parser, definition);
  if (fn !== undefined) {
    return function (maybe, map) {
      return Curry._2(fn, maybe, map).then(function (param) {
                  return Promise.resolve([
                              key,
                              param
                            ]);
                });
    };
  } else {
    return function (maybe, param) {
      return Promise.resolve([
                  key,
                  maybe
                ]);
    };
  }
}

function compiler(param) {
  return make((function (key, definition, input) {
                return Curry._1(definition.read, input).then(function (param) {
                            return Promise.resolve([
                                        key,
                                        param
                                      ]);
                          });
              }), param);
}

function parser(definition) {
  return definition.sanitize;
}

function compiler$1(param) {
  return make((function (key, definition) {
                var sanitizer = actionOrDefault(parser, key, definition);
                return function (parsed) {
                  return Curry._2(sanitizer, Awesomize_util.unwrap(Belt_MapString.get(parsed, key)), parsed);
                };
              }), param);
}

function parser$1(definition) {
  return definition.normalize;
}

function compiler$2(param) {
  return make((function (key, definition) {
                var normalizer = actionOrDefault(parser$1, key, definition);
                return function (parsed) {
                  return Curry._2(normalizer, Awesomize_util.unwrap(Belt_MapString.get(parsed, key)), parsed);
                };
              }), param);
}

function iterate(key, test, input, next) {
  return Curry._2(test, Awesomize_util.unwrap(Belt_MapString.get(input, key)), input).then(function (message) {
              if (message !== undefined) {
                return Promise.resolve([
                            key,
                            {
                              NAME: "Invalid",
                              VAL: Caml_option.valFromOption(message)
                            }
                          ]);
              } else {
                return Curry._1(next, input);
              }
            });
}

function run(key, listOfValidations, input) {
  if (!listOfValidations) {
    return Promise.resolve([
                key,
                "Valid"
              ]);
  }
  var rest = listOfValidations.tl;
  var test = listOfValidations.hd;
  if (rest) {
    return iterate(key, test, input, (function (param) {
                  return run(key, rest, param);
                }));
  } else {
    return iterate(key, test, input, (function (param) {
                  return run(key, /* [] */0, param);
                }));
  }
}

function compiler$3(param) {
  return make((function (key, definition) {
                var tests = definition.validate;
                if (tests) {
                  return function (param) {
                    return run(key, tests, param);
                  };
                } else {
                  return Js_exn.raiseError("You must provide at least one validator for key: " + key);
                }
              }), param);
}

function hasError(res) {
  return Belt_MapString.some(res, (function (param, v) {
                if (typeof v === "string") {
                  return false;
                } else {
                  return true;
                }
              }));
}

function toErrorMap(res) {
  return Belt_MapString.map(res, (function (param) {
                if (typeof param === "string") {
                  return ;
                } else {
                  return Caml_option.some(param.VAL);
                }
              }));
}

function convertScrubber(scrubber) {
  if (!(scrubber == null)) {
    return (function (maybe, parsed) {
              if (maybe !== undefined) {
                return scrubber(Caml_option.valFromOption(maybe), parsed).then(function (result) {
                            return Promise.resolve((result == null) ? undefined : Caml_option.some(result));
                          });
              } else {
                return Promise.resolve(undefined);
              }
            });
  }
  
}

function inputConvert(input) {
  return $$Array.map((function (param) {
                var def = param[1];
                var partial_arg = def.read;
                return [
                        param[0],
                        {
                          read: (function (param) {
                              return Curry._1(partial_arg, param).then(function (result) {
                                          return Promise.resolve((result == null) ? undefined : Caml_option.some(result));
                                        });
                            }),
                          sanitize: convertScrubber(def.sanitize),
                          validate: Belt_List.fromArray(def.validate),
                          normalize: convertScrubber(def.normalize)
                        }
                      ];
              }), input);
}

function make$1(array) {
  var definitionMap = Belt_MapString.fromArray(array);
  var read = compiler(definitionMap);
  var sanitize = compiler$1(definitionMap);
  var validate = compiler$3(definitionMap);
  var normalize = compiler$2(definitionMap);
  var unwrapMap = function (m1) {
    return Belt_MapString.reduce(m1, undefined, (function (m2, key, value) {
                  if (value !== undefined) {
                    return Belt_MapString.set(m2, key, Caml_option.valFromOption(value));
                  } else {
                    return m2;
                  }
                }));
  };
  return function (input) {
    return Curry._1(read, input).then(Curry.__1(sanitize)).then(function (sanitized) {
                  return Curry._1(validate, sanitized).then(function (validated) {
                              return Promise.resolve([
                                          validated,
                                          sanitized
                                        ]);
                            });
                }).then(function (param) {
                var validated = param[0];
                if (hasError(validated)) {
                  var map = toErrorMap(validated);
                  return Promise.resolve({
                              NAME: "Error",
                              VAL: map
                            });
                } else {
                  var sanitized = param[1];
                  return Curry._1(normalize, sanitized).then(function (normalized) {
                              var x = unwrapMap(normalized);
                              return Promise.resolve({
                                          NAME: "Ok",
                                          VAL: x
                                        });
                            });
                }
              });
  };
}

function fromJs(input) {
  return make$1(inputConvert(input));
}

var Read;

var Result;

var Normalizer;

var Sanitizer;

var Validator;

exports.definitionToJs = definitionToJs;
exports.definitionFromJs = definitionFromJs;
exports.make = make$1;
exports.fromJs = fromJs;
exports.Read = Read;
exports.Result = Result;
exports.Normalizer = Normalizer;
exports.Sanitizer = Sanitizer;
exports.Validator = Validator;
/* No side effect */
