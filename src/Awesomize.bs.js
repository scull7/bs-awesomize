// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Awesomize_util = require("./Awesomize_util.bs.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function definitionToJs(param) {
  return {
          read: param[/* read */0],
          sanitize: param[/* sanitize */1],
          validate: param[/* validate */2],
          normalize: param[/* normalize */3]
        };
}

function definitionFromJs(param) {
  return /* record */[
          /* read */param.read,
          /* sanitize */param.sanitize,
          /* validate */param.validate,
          /* normalize */param.normalize
        ];
}

function make(generator, definitionMap) {
  var step = Belt_MapString.valuesToArray(Belt_MapString.mapWithKey(definitionMap, generator));
  return (function (input) {
      return Promise.all(Belt_Array.map(step, (function (fn) {
                          return Curry._1(fn, input);
                        }))).then((function (res) {
                    return Promise.resolve(Belt_MapString.fromArray(res));
                  }));
    });
}

function resolver(key, value) {
  return Promise.resolve(/* tuple */[
              key,
              value
            ]);
}

function actionOrDefault(parser, key, definition) {
  var match = Curry._1(parser, definition);
  if (match) {
    var fn = match[0];
    return (function (maybe, map) {
        return Curry._2(fn, maybe, map).then((function (param) {
                      return Promise.resolve(/* tuple */[
                                  key,
                                  param
                                ]);
                    }));
      });
  } else {
    return (function (maybe, _) {
        return Promise.resolve(/* tuple */[
                    key,
                    maybe
                  ]);
      });
  }
}

function compiler(param) {
  return make((function (key, definition, input) {
                return Curry._1(definition[/* read */0], input).then((function (param) {
                              return Promise.resolve(/* tuple */[
                                          key,
                                          param
                                        ]);
                            }));
              }), param);
}

function parser(definition) {
  return definition[/* sanitize */1];
}

function compiler$1(param) {
  return make((function (key, definition) {
                var sanitizer = actionOrDefault(parser, key, definition);
                return (function (parsed) {
                    return Curry._2(sanitizer, Awesomize_util.unwrap(Belt_MapString.get(parsed, key)), parsed);
                  });
              }), param);
}

function parser$1(definition) {
  return definition[/* normalize */3];
}

function compiler$2(param) {
  return make((function (key, definition) {
                var normalizer = actionOrDefault(parser$1, key, definition);
                return (function (parsed) {
                    return Curry._2(normalizer, Awesomize_util.unwrap(Belt_MapString.get(parsed, key)), parsed);
                  });
              }), param);
}

function iterate(key, test, input, next) {
  return Curry._2(test, Awesomize_util.unwrap(Belt_MapString.get(input, key)), input).then((function (param) {
                if (param) {
                  return Promise.resolve(/* tuple */[
                              key,
                              /* `Invalid */[
                                144245463,
                                param[0]
                              ]
                            ]);
                } else {
                  return Curry._1(next, input);
                }
              }));
}

function run(key, listOfValidations, input) {
  if (listOfValidations) {
    var rest = listOfValidations[1];
    var test = listOfValidations[0];
    if (rest) {
      return iterate(key, test, input, (function (param) {
                    return run(key, rest, param);
                  }));
    } else {
      return iterate(key, test, input, (function () {
                    return Curry._2(/* resolver */resolver, key, /* Valid */-991566628);
                  }));
    }
  } else {
    return Promise.resolve(/* tuple */[
                key,
                /* Valid */-991566628
              ]);
  }
}

function compiler$3(param) {
  return make((function (key, definition) {
                var tests = definition[/* validate */2];
                if (tests) {
                  return (function (param) {
                      return run(key, tests, param);
                    });
                } else {
                  return Pervasives.failwith("You must provide at least one validator for key: " + (String(key) + ""));
                }
              }), param);
}

function hasError(res) {
  return Belt_MapString.some(res, (function (_, v) {
                if (typeof v === "number") {
                  return false;
                } else {
                  return true;
                }
              }));
}

function toErrorMap(res) {
  return Belt_MapString.map(res, (function (param) {
                if (typeof param === "number") {
                  return /* None */0;
                } else {
                  return /* Some */[param[1]];
                }
              }));
}

function convertScrubber(scrubber) {
  if (scrubber == null) {
    return /* None */0;
  } else {
    return /* Some */[(function (maybe, parsed) {
                if (maybe) {
                  return scrubber(maybe[0], parsed).then((function (result) {
                                return Promise.resolve((result == null) ? /* None */0 : [result]);
                              }));
                } else {
                  return Promise.resolve(/* None */0);
                }
              })];
  }
}

function inputConvert(input) {
  return $$Array.map((function (param) {
                var def = param[1];
                var partial_arg = def.read;
                return /* tuple */[
                        param[0],
                        /* record */[
                          /* read */(function (param) {
                              var read = partial_arg;
                              var json = param;
                              return Curry._1(read, json).then((function (result) {
                                            return Promise.resolve((result == null) ? /* None */0 : [result]);
                                          }));
                            }),
                          /* sanitize */convertScrubber(def.sanitize),
                          /* validate */Belt_List.fromArray(def.validate),
                          /* normalize */convertScrubber(def.normalize)
                        ]
                      ];
              }), input);
}

function make$1(array) {
  var definitionMap = Belt_MapString.fromArray(array);
  var read = compiler(definitionMap);
  var sanitize = compiler$1(definitionMap);
  var validate = compiler$3(definitionMap);
  var normalize = compiler$2(definitionMap);
  var unwrapMap = function (m1) {
    return Belt_MapString.reduce(m1, Belt_MapString.empty, (function (m2, key, value) {
                  if (value) {
                    return Belt_MapString.set(m2, key, value[0]);
                  } else {
                    return m2;
                  }
                }));
  };
  return (function (input) {
      return Curry._1(read, input).then(Curry.__1(sanitize)).then((function (sanitized) {
                      return Curry._1(validate, sanitized).then((function (validated) {
                                    return Promise.resolve(/* tuple */[
                                                validated,
                                                sanitized
                                              ]);
                                  }));
                    })).then((function (param) {
                    var validated = param[0];
                    var match = hasError(validated);
                    if (match) {
                      var validated$1 = validated;
                      var map = toErrorMap(validated$1);
                      return Promise.resolve(/* `Error */[
                                  106380200,
                                  map
                                ]);
                    } else {
                      var sanitized = param[1];
                      return Curry._1(normalize, sanitized).then((function (normalized) {
                                    var x = unwrapMap(normalized);
                                    return Promise.resolve(/* `Ok */[
                                                17724,
                                                x
                                              ]);
                                  }));
                    }
                  }));
    });
}

function fromJs(input) {
  return make$1(inputConvert(input));
}

var Read = 0;

var Result = 0;

var Normalizer = 0;

var Sanitizer = 0;

var Validator = 0;

exports.definitionToJs = definitionToJs;
exports.definitionFromJs = definitionFromJs;
exports.make = make$1;
exports.fromJs = fromJs;
exports.Read = Read;
exports.Result = Result;
exports.Normalizer = Normalizer;
exports.Sanitizer = Sanitizer;
exports.Validator = Validator;
/* No side effect */
